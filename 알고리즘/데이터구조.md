# Swift ë°ì´í„° êµ¬ì¡°

## Stack

```swift
import Cocoa

class Stack<T: CustomStringConvertible>: CustomStringConvertible {
    
    private var array: [T] = []
    
    func pop() -> T? {
        let popItem = self.array.popLast()
        print("POP ITEM : \(popItem?.description ?? "")")
        return popItem
    }
    
    func push(item: T) {
        print("PUSH ITEM : \(item.description)")
        array.append(item)
    }
    
    var isEmpty: Bool {
        return self.array.isEmpty
    }
    
    var count: Int {
        return self.array.count
    }
    
    var description: String {
        let top = "### STACK ###\n"
        let bottom = "\n#############\n"
        let elements = self.array.reversed().map { $0.description }.joined(separator: "\n")
        return top + elements + bottom
    }
    
}

let obj = Stack<String>()
obj.push(item: "A")
obj.push(item: "B")
obj.push(item: "C")
obj.push(item: "D")
obj.push(item: "E")
print("STACK COUNT: \(obj.count)")
print(obj.description)
let _ = obj.pop()
print(obj.description)
let _ = obj.description
print("STACK COUNT: \(obj.count)")
print(obj.description)

/*
 1. ìˆ«ì ë°°ì—´ë¡œ ë§Œë“¤ê¸°
 2. queue/dequeue ë§Œë“¤ê¸°
 */


```

**ê²°ê³¼ê°’**

```
PUSH ITEM : A
PUSH ITEM : B
PUSH ITEM : C
PUSH ITEM : D
PUSH ITEM : E
STACK COUNT: 5
### STACK ###
E
D
C
B
A
#############

POP ITEM : E
### STACK ###
D
C
B
A
#############

STACK COUNT: 4
### STACK ###
D
C
B
A
#############
```



- CustomStringConvertible: ìê¸° ìì‹ ì„ í‘œí˜„í•˜ëŠ” ë¬¸ìì—´ì„ ì •ì˜, ê°„ë‹¨í•œ ë§ë¡œ ìŠ¤ìŠ¤ë¡œê°€ ë­”ì§€ë¥¼ ë¬¸ìì—´ë¡œ ì •ì˜í•´ ë†“ëŠ” ê²ƒì´ë‹¤.

```swift
struct Dog: CustomStringConvertible {
  var name: String
  var description: String {
    return "ğŸ¶ \(self.name)"
  }
}

let dog = Dog(name: "ì°¡ì½”")
print(dog) // ğŸ¶ ì°¡ì½”
```



- **Pop** : ë°°ì—´ì˜ ë§ˆì§€ë§‰ ìš”ì†Œ ì œê±°
- **Push** : ë°°ì—´ì˜ ë§ˆì§€ë§‰ì— ìƒˆë¡œìš´ ìš”ì†Œ ì¶”ê°€
- **isEmpty** : ë¹„ì–´ ìˆìœ¼ë©´ true, ì•„ë‹ˆë©´ false
- **count** : ë°°ì—´ì˜ ê°¯ìˆ˜
- **description** : 



## Link List

```swift

class Node<T> {
    var data: T
    var next: Node?
    
    init(data: T, next: Node? = nil) {
        self.data = data
        self.next = next
    }
}

class LinkList<T>: CustomStringConvertible where T: Comparable, T: CustomStringConvertible {
    private var startNode: Node<T>?
    
    var isEmpty: Bool {
        return self.startNode == nil
    }
        
    // APPEND NODE FROM LAST
    func append(element: T) {
        let item = Node(data: element)
        if var node = self.startNode {
            while node.next != nil {
                node = node.next!
            }
            node.next = item
        } else {
            self.startNode = item
        }
    }
    
    // INSERT NODE AT BEGINNING
    func insert(element: T) {
        let item = Node(data: element)
        item.next = self.startNode
        self.startNode = item
    }
    
    // INSERT NODE AT PARTICULAR POSITION
    func insert(position: Int, element: T) {
        if position == 0 {
            self.insert(element: element)
        } else {
            let item = Node(data: element)
            var nextNode = self.startNode
            var previousNode: Node<T>?
            
            for _ in 0..<position {
                previousNode = nextNode
                nextNode = nextNode?.next
            }
            
            previousNode?.next = item
            item.next = nextNode
        }
    }
    
    func removeFirst() {
        self.startNode = self.startNode?.next
    }
    
    // REMOVE NODE FROM END
    func removeLast() {
        var nextNode = self.startNode
        var previousNode: Node<T>?
        while nextNode?.next != nil {
            previousNode = nextNode
            nextNode = nextNode?.next
        }
        previousNode?.next = nextNode?.next
    }
    
    func remove(at position: Int) {
        if position == 0 {
            self.removeFirst()
        } else {
            var nextNode = self.startNode
            var previousNode: Node<T>?
            for _ in 0..<position {
                previousNode = nextNode
                nextNode = nextNode?.next
            }
            previousNode?.next = nextNode?.next
        }
    }
    
    // SEARCH A PARTICULAR NODE
    func search(element: T) -> Int {
        var node = self.startNode
        var count = 0
        while node != nil {
            if node?.data == element {
                return count
            }
            count += 1
            node = node?.next
        }
        return count
    }
    
    var description: String {
        var data = ""
        let top = "### LINK LIST ###\n"
        let bottom = "\n#############\n"
        var node = self.startNode
        while node != nil {
            data += (node?.data.description)! + "\n"
            node = node?.next
        }
        return top + data + bottom
    }
}

let linkList = LinkList<Int>()
linkList.append(element: 0)
linkList.append(element: 1)
linkList.append(element: 2)
linkList.append(element: 3)
linkList.append(element: 4)
linkList.append(element: 5)
print(linkList.description)
linkList.insert(element: 100)
print(linkList.description)
linkList.insert(position: 4, element: 1000)
print(linkList.description)
print(linkList.search(element: 2))
print(linkList.description)
linkList.removeFirst()
print(linkList.description)
linkList.removeLast()
print(linkList.description)
linkList.remove(at: 3)
print(linkList.description)


/*
 1. ì•ŒíŒŒë²³ ë§í¬ ëª©ë¡ ë§Œë“¤ê¸°
 2. ì´ì¤‘/ì›í˜• ë§í¬ ëª©ë¡ ë§Œë“¤ê¸°
 */
```

**ê²°ê³¼ê°’**

```
### LINK LIST ###
0
1
2
3
4
5

#############

### LINK LIST ###
100
0
1
2
3
4
5

#############

### LINK LIST ###
100
0
1
2
1000
3
4
5

#############

3
### LINK LIST ###
100
0
1
2
1000
3
4
5

#############

### LINK LIST ###
0
1
2
1000
3
4
5

#############

### LINK LIST ###
0
1
2
1000
3
4

#############

### LINK LIST ###
0
1
2
3
4

#############
```

## ì°¸ê³  ìë£Œ

https://medium.com/nickelfox/playing-with-data-structure-in-swift-ccd8efca9611

https://devxoul.gitbooks.io/ios-with-swift-in-40-hours/Chapter-3/protocols.html