# ğŸŒ DFS & BFS â€” ì¸ì ‘ í–‰ë ¬ êµ¬í˜„ + í™œìš© ì˜ˆì œ

## 1ï¸âƒ£ ì¸ì ‘ í–‰ë ¬ ê¸°ë°˜ DFS êµ¬í˜„ (Swift)

```swift
func dfsMatrix(_ graph: [[Int]], _ v: Int, _ visited: inout [Bool]) {
    visited[v] = true
    print(v, terminator: " ")

    for i in 0..<graph.count {
        if graph[v][i] == 1 && !visited[i] {
            dfsMatrix(graph, i, &visited)
        }
    }
}
```

## 2ï¸âƒ£ ì¸ì ‘ í–‰ë ¬ ê¸°ë°˜ BFS êµ¬í˜„ (Swift)

```swift
func bfsMatrix(_ graph: [[Int]], _ start: Int) {
    var visited = Array(repeating: false, count: graph.count)
    var queue: [Int] = [start]
    visited[start] = true

    while !queue.isEmpty {
        let v = queue.removeFirst()
        print(v, terminator: " ")

        for i in 0..<graph.count {
            if graph[v][i] == 1 && !visited[i] {
                queue.append(i)
                visited[i] = true
            }
        }
    }
}
```

### âœ… í…ŒìŠ¤íŠ¸ìš© ê·¸ë˜í”„ ì˜ˆì œ

```swift
let graphMatrix = [
    [0, 1, 1, 0, 0],
    [1, 0, 1, 1, 0],
    [1, 1, 0, 0, 0],
    [0, 1, 0, 0, 1],
    [0, 0, 0, 1, 0]
]

var visitedDFS = Array(repeating: false, count: graphMatrix.count)
print("DFS:")
dfsMatrix(graphMatrix, 0, &visitedDFS)  // ì¶œë ¥: 0 1 2 3 4

print("\nBFS:")
bfsMatrix(graphMatrix, 0)               // ì¶œë ¥: 0 1 2 3 4
```

---

## 3ï¸âƒ£ DFS/BFS í™œìš© ì˜ˆì‹œ ë¬¸ì œ

---

### ğŸ§­ ì˜ˆì œ 1: **ë¯¸ë¡œ íƒìƒ‰ (ìµœë‹¨ ê²½ë¡œ - BFS)**

> `0`: ê°ˆ ìˆ˜ ì—†ëŠ” ê³³, `1`: ê°ˆ ìˆ˜ ìˆëŠ” ê³³
> ì¶œë°œì : `(0,0)` â†’ ë„ì°©ì : `(N-1,M-1)`

```swift
import Foundation

let maze: [[Int]] = [
    [1, 1, 0, 1],
    [0, 1, 1, 0],
    [0, 1, 0, 1],
    [1, 1, 1, 1]
]

let dx = [0, 0, -1, 1]
let dy = [-1, 1, 0, 0]

func bfsMaze(_ maze: [[Int]]) -> Int {
    var queue: [(Int, Int)] = [(0, 0)]
    var distance = Array(repeating: Array(repeating: 0, count: maze[0].count), count: maze.count)
    distance[0][0] = 1

    while !queue.isEmpty {
        let (x, y) = queue.removeFirst()

        for i in 0..<4 {
            let nx = x + dx[i]
            let ny = y + dy[i]

            if nx >= 0, ny >= 0, nx < maze.count, ny < maze[0].count,
               maze[nx][ny] == 1, distance[nx][ny] == 0 {
                distance[nx][ny] = distance[x][y] + 1
                queue.append((nx, ny))
            }
        }
    }

    return distance[maze.count - 1][maze[0].count - 1]
}

print("ìµœë‹¨ ê±°ë¦¬: \(bfsMaze(maze))")  // ì¶œë ¥: ìµœë‹¨ ê±°ë¦¬: 7
```

---

### ğŸŒŠ ì˜ˆì œ 2: **ì„¬ì˜ ê°œìˆ˜ êµ¬í•˜ê¸° (DFS)**

> 2ì°¨ì› ë§µì—ì„œ `1`ì€ ë•…, `0`ì€ ë°”ë‹¤.
> ìƒí•˜ì¢Œìš° + ëŒ€ê°ì„ ê¹Œì§€ ì´ 8ë°©í–¥ìœ¼ë¡œ ì—°ê²°ëœ ë•…ì„ **í•˜ë‚˜ì˜ ì„¬**ìœ¼ë¡œ ë³¸ë‹¤.

```swift
let map = [
    [1, 1, 0, 0, 0],
    [1, 1, 0, 0, 1],
    [0, 0, 0, 1, 1],
    [0, 0, 0, 0, 0],
    [1, 0, 1, 0, 1]
]

let dx8 = [-1,-1,-1, 0, 0, 1, 1, 1]
let dy8 = [-1, 0, 1, -1, 1, -1, 0, 1]

func dfsIsland(_ x: Int, _ y: Int, _ map: inout [[Int]]) {
    let n = map.count
    let m = map[0].count
    map[x][y] = 0  // ë°©ë¬¸ ì²˜ë¦¬

    for dir in 0..<8 {
        let nx = x + dx8[dir]
        let ny = y + dy8[dir]

        if nx >= 0, ny >= 0, nx < n, ny < m, map[nx][ny] == 1 {
            dfsIsland(nx, ny, &map)
        }
    }
}

func countIslands(_ inputMap: [[Int]]) -> Int {
    var map = inputMap
    var count = 0

    for i in 0..<map.count {
        for j in 0..<map[0].count {
            if map[i][j] == 1 {
                dfsIsland(i, j, &map)
                count += 1
            }
        }
    }
    return count
}

print("ì„¬ì˜ ê°œìˆ˜: \(countIslands(map))")  // ì¶œë ¥: ì„¬ì˜ ê°œìˆ˜: 5
```

---

## ğŸ“š ìš”ì•½

| ë¬¸ì œ ìœ í˜•    | ì‚¬ìš© ì•Œê³ ë¦¬ì¦˜ | ì´ìœ            |
| -------- | ------- | ------------ |
| ë¯¸ë¡œ íƒìƒ‰    | **BFS** | ìµœë‹¨ ê±°ë¦¬ íƒìƒ‰     |
| ì„¬ ê°œìˆ˜ êµ¬í•˜ê¸° | **DFS** | ëª¨ë“  ì—°ê²°ëœ ì˜ì—­ ìˆœíšŒ |
